// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `parser/onnx_model/onnx.proto3`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:onnx.AttributeProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AttributeProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.AttributeProto.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.AttributeProto.doc_string)
    pub doc_string: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.AttributeProto.type)
    pub type_: ::protobuf::EnumOrUnknown<attribute_proto::AttributeType>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.f)
    pub f: f32,
    // @@protoc_insertion_point(field:onnx.AttributeProto.i)
    pub i: i64,
    // @@protoc_insertion_point(field:onnx.AttributeProto.s)
    pub s: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.t)
    pub t: ::protobuf::MessageField<TensorProto>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.g)
    pub g: ::protobuf::MessageField<GraphProto>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.floats)
    pub floats: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.ints)
    pub ints: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.strings)
    pub strings: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.tensors)
    pub tensors: ::std::vec::Vec<TensorProto>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.graphs)
    pub graphs: ::std::vec::Vec<GraphProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.AttributeProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AttributeProto {
    fn default() -> &'a AttributeProto {
        <AttributeProto as ::protobuf::Message>::default_instance()
    }
}

impl AttributeProto {
    pub fn new() -> AttributeProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AttributeProto| { &m.name },
            |m: &mut AttributeProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "doc_string",
            |m: &AttributeProto| { &m.doc_string },
            |m: &mut AttributeProto| { &mut m.doc_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &AttributeProto| { &m.type_ },
            |m: &mut AttributeProto| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "f",
            |m: &AttributeProto| { &m.f },
            |m: &mut AttributeProto| { &mut m.f },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "i",
            |m: &AttributeProto| { &m.i },
            |m: &mut AttributeProto| { &mut m.i },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "s",
            |m: &AttributeProto| { &m.s },
            |m: &mut AttributeProto| { &mut m.s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TensorProto>(
            "t",
            |m: &AttributeProto| { &m.t },
            |m: &mut AttributeProto| { &mut m.t },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GraphProto>(
            "g",
            |m: &AttributeProto| { &m.g },
            |m: &mut AttributeProto| { &mut m.g },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "floats",
            |m: &AttributeProto| { &m.floats },
            |m: &mut AttributeProto| { &mut m.floats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ints",
            |m: &AttributeProto| { &m.ints },
            |m: &mut AttributeProto| { &mut m.ints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &AttributeProto| { &m.strings },
            |m: &mut AttributeProto| { &mut m.strings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tensors",
            |m: &AttributeProto| { &m.tensors },
            |m: &mut AttributeProto| { &mut m.tensors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "graphs",
            |m: &AttributeProto| { &m.graphs },
            |m: &mut AttributeProto| { &mut m.graphs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AttributeProto>(
            "AttributeProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AttributeProto {
    const NAME: &'static str = "AttributeProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                106 => {
                    self.doc_string = is.read_string()?;
                },
                160 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                21 => {
                    self.f = is.read_float()?;
                },
                24 => {
                    self.i = is.read_int64()?;
                },
                34 => {
                    self.s = is.read_bytes()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.t)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.g)?;
                },
                58 => {
                    is.read_repeated_packed_float_into(&mut self.floats)?;
                },
                61 => {
                    self.floats.push(is.read_float()?);
                },
                66 => {
                    is.read_repeated_packed_int64_into(&mut self.ints)?;
                },
                64 => {
                    self.ints.push(is.read_int64()?);
                },
                74 => {
                    self.strings.push(is.read_bytes()?);
                },
                82 => {
                    self.tensors.push(is.read_message()?);
                },
                90 => {
                    self.graphs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.doc_string);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(attribute_proto::AttributeType::UNDEFINED) {
            my_size += ::protobuf::rt::int32_size(20, self.type_.value());
        }
        if self.f != 0. {
            my_size += 1 + 4;
        }
        if self.i != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.i);
        }
        if !self.s.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.s);
        }
        if let Some(v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.g.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.floats.len() as u64;
        for value in &self.ints {
            my_size += ::protobuf::rt::int64_size(8, *value);
        };
        for value in &self.strings {
            my_size += ::protobuf::rt::bytes_size(9, &value);
        };
        for value in &self.tensors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.doc_string.is_empty() {
            os.write_string(13, &self.doc_string)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(attribute_proto::AttributeType::UNDEFINED) {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.f != 0. {
            os.write_float(2, self.f)?;
        }
        if self.i != 0 {
            os.write_int64(3, self.i)?;
        }
        if !self.s.is_empty() {
            os.write_bytes(4, &self.s)?;
        }
        if let Some(v) = self.t.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.g.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.floats {
            os.write_float(7, *v)?;
        };
        for v in &self.ints {
            os.write_int64(8, *v)?;
        };
        for v in &self.strings {
            os.write_bytes(9, &v)?;
        };
        for v in &self.tensors {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.graphs {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AttributeProto {
        AttributeProto::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.doc_string.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(attribute_proto::AttributeType::UNDEFINED);
        self.f = 0.;
        self.i = 0;
        self.s.clear();
        self.t.clear();
        self.g.clear();
        self.floats.clear();
        self.ints.clear();
        self.strings.clear();
        self.tensors.clear();
        self.graphs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AttributeProto {
        static instance: AttributeProto = AttributeProto {
            name: ::std::string::String::new(),
            doc_string: ::std::string::String::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            f: 0.,
            i: 0,
            s: ::std::vec::Vec::new(),
            t: ::protobuf::MessageField::none(),
            g: ::protobuf::MessageField::none(),
            floats: ::std::vec::Vec::new(),
            ints: ::std::vec::Vec::new(),
            strings: ::std::vec::Vec::new(),
            tensors: ::std::vec::Vec::new(),
            graphs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AttributeProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AttributeProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AttributeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AttributeProto`
pub mod attribute_proto {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:onnx.AttributeProto.AttributeType)
    pub enum AttributeType {
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.UNDEFINED)
        UNDEFINED = 0,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.FLOAT)
        FLOAT = 1,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.INT)
        INT = 2,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.STRING)
        STRING = 3,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.TENSOR)
        TENSOR = 4,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.GRAPH)
        GRAPH = 5,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.FLOATS)
        FLOATS = 6,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.INTS)
        INTS = 7,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.STRINGS)
        STRINGS = 8,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.TENSORS)
        TENSORS = 9,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.GRAPHS)
        GRAPHS = 10,
    }

    impl ::protobuf::Enum for AttributeType {
        const NAME: &'static str = "AttributeType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AttributeType> {
            match value {
                0 => ::std::option::Option::Some(AttributeType::UNDEFINED),
                1 => ::std::option::Option::Some(AttributeType::FLOAT),
                2 => ::std::option::Option::Some(AttributeType::INT),
                3 => ::std::option::Option::Some(AttributeType::STRING),
                4 => ::std::option::Option::Some(AttributeType::TENSOR),
                5 => ::std::option::Option::Some(AttributeType::GRAPH),
                6 => ::std::option::Option::Some(AttributeType::FLOATS),
                7 => ::std::option::Option::Some(AttributeType::INTS),
                8 => ::std::option::Option::Some(AttributeType::STRINGS),
                9 => ::std::option::Option::Some(AttributeType::TENSORS),
                10 => ::std::option::Option::Some(AttributeType::GRAPHS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<AttributeType> {
            match str {
                "UNDEFINED" => ::std::option::Option::Some(AttributeType::UNDEFINED),
                "FLOAT" => ::std::option::Option::Some(AttributeType::FLOAT),
                "INT" => ::std::option::Option::Some(AttributeType::INT),
                "STRING" => ::std::option::Option::Some(AttributeType::STRING),
                "TENSOR" => ::std::option::Option::Some(AttributeType::TENSOR),
                "GRAPH" => ::std::option::Option::Some(AttributeType::GRAPH),
                "FLOATS" => ::std::option::Option::Some(AttributeType::FLOATS),
                "INTS" => ::std::option::Option::Some(AttributeType::INTS),
                "STRINGS" => ::std::option::Option::Some(AttributeType::STRINGS),
                "TENSORS" => ::std::option::Option::Some(AttributeType::TENSORS),
                "GRAPHS" => ::std::option::Option::Some(AttributeType::GRAPHS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AttributeType] = &[
            AttributeType::UNDEFINED,
            AttributeType::FLOAT,
            AttributeType::INT,
            AttributeType::STRING,
            AttributeType::TENSOR,
            AttributeType::GRAPH,
            AttributeType::FLOATS,
            AttributeType::INTS,
            AttributeType::STRINGS,
            AttributeType::TENSORS,
            AttributeType::GRAPHS,
        ];
    }

    impl ::protobuf::EnumFull for AttributeType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("AttributeProto.AttributeType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for AttributeType {
        fn default() -> Self {
            AttributeType::UNDEFINED
        }
    }

    impl AttributeType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AttributeType>("AttributeProto.AttributeType")
        }
    }
}

// @@protoc_insertion_point(message:onnx.ValueInfoProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValueInfoProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.ValueInfoProto.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.ValueInfoProto.type)
    pub type_: ::protobuf::MessageField<TypeProto>,
    // @@protoc_insertion_point(field:onnx.ValueInfoProto.doc_string)
    pub doc_string: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.ValueInfoProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValueInfoProto {
    fn default() -> &'a ValueInfoProto {
        <ValueInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl ValueInfoProto {
    pub fn new() -> ValueInfoProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ValueInfoProto| { &m.name },
            |m: &mut ValueInfoProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TypeProto>(
            "type",
            |m: &ValueInfoProto| { &m.type_ },
            |m: &mut ValueInfoProto| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "doc_string",
            |m: &ValueInfoProto| { &m.doc_string },
            |m: &mut ValueInfoProto| { &mut m.doc_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValueInfoProto>(
            "ValueInfoProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValueInfoProto {
    const NAME: &'static str = "ValueInfoProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                },
                26 => {
                    self.doc_string = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(v) = self.type_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.doc_string);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(v) = self.type_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.doc_string.is_empty() {
            os.write_string(3, &self.doc_string)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValueInfoProto {
        ValueInfoProto::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.type_.clear();
        self.doc_string.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValueInfoProto {
        static instance: ValueInfoProto = ValueInfoProto {
            name: ::std::string::String::new(),
            type_: ::protobuf::MessageField::none(),
            doc_string: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValueInfoProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValueInfoProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValueInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueInfoProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:onnx.NodeProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.NodeProto.input)
    pub input: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:onnx.NodeProto.output)
    pub output: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:onnx.NodeProto.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.NodeProto.op_type)
    pub op_type: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.NodeProto.domain)
    pub domain: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.NodeProto.attribute)
    pub attribute: ::std::vec::Vec<AttributeProto>,
    // @@protoc_insertion_point(field:onnx.NodeProto.doc_string)
    pub doc_string: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.NodeProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeProto {
    fn default() -> &'a NodeProto {
        <NodeProto as ::protobuf::Message>::default_instance()
    }
}

impl NodeProto {
    pub fn new() -> NodeProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input",
            |m: &NodeProto| { &m.input },
            |m: &mut NodeProto| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output",
            |m: &NodeProto| { &m.output },
            |m: &mut NodeProto| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &NodeProto| { &m.name },
            |m: &mut NodeProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "op_type",
            |m: &NodeProto| { &m.op_type },
            |m: &mut NodeProto| { &mut m.op_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &NodeProto| { &m.domain },
            |m: &mut NodeProto| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attribute",
            |m: &NodeProto| { &m.attribute },
            |m: &mut NodeProto| { &mut m.attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "doc_string",
            |m: &NodeProto| { &m.doc_string },
            |m: &mut NodeProto| { &mut m.doc_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeProto>(
            "NodeProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeProto {
    const NAME: &'static str = "NodeProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.input.push(is.read_string()?);
                },
                18 => {
                    self.output.push(is.read_string()?);
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.op_type = is.read_string()?;
                },
                58 => {
                    self.domain = is.read_string()?;
                },
                42 => {
                    self.attribute.push(is.read_message()?);
                },
                50 => {
                    self.doc_string = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.input {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.output {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.op_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.op_type);
        }
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.domain);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.doc_string);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.input {
            os.write_string(1, &v)?;
        };
        for v in &self.output {
            os.write_string(2, &v)?;
        };
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.op_type.is_empty() {
            os.write_string(4, &self.op_type)?;
        }
        if !self.domain.is_empty() {
            os.write_string(7, &self.domain)?;
        }
        for v in &self.attribute {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if !self.doc_string.is_empty() {
            os.write_string(6, &self.doc_string)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeProto {
        NodeProto::new()
    }

    fn clear(&mut self) {
        self.input.clear();
        self.output.clear();
        self.name.clear();
        self.op_type.clear();
        self.domain.clear();
        self.attribute.clear();
        self.doc_string.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeProto {
        static instance: NodeProto = NodeProto {
            input: ::std::vec::Vec::new(),
            output: ::std::vec::Vec::new(),
            name: ::std::string::String::new(),
            op_type: ::std::string::String::new(),
            domain: ::std::string::String::new(),
            attribute: ::std::vec::Vec::new(),
            doc_string: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:onnx.ModelProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.ModelProto.ir_version)
    pub ir_version: i64,
    // @@protoc_insertion_point(field:onnx.ModelProto.opset_import)
    pub opset_import: ::std::vec::Vec<OperatorSetIdProto>,
    // @@protoc_insertion_point(field:onnx.ModelProto.producer_name)
    pub producer_name: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.ModelProto.producer_version)
    pub producer_version: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.ModelProto.domain)
    pub domain: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.ModelProto.model_version)
    pub model_version: i64,
    // @@protoc_insertion_point(field:onnx.ModelProto.doc_string)
    pub doc_string: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.ModelProto.graph)
    pub graph: ::protobuf::MessageField<GraphProto>,
    // @@protoc_insertion_point(field:onnx.ModelProto.metadata_props)
    pub metadata_props: ::std::vec::Vec<StringStringEntryProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.ModelProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelProto {
    fn default() -> &'a ModelProto {
        <ModelProto as ::protobuf::Message>::default_instance()
    }
}

impl ModelProto {
    pub fn new() -> ModelProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ir_version",
            |m: &ModelProto| { &m.ir_version },
            |m: &mut ModelProto| { &mut m.ir_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "opset_import",
            |m: &ModelProto| { &m.opset_import },
            |m: &mut ModelProto| { &mut m.opset_import },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "producer_name",
            |m: &ModelProto| { &m.producer_name },
            |m: &mut ModelProto| { &mut m.producer_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "producer_version",
            |m: &ModelProto| { &m.producer_version },
            |m: &mut ModelProto| { &mut m.producer_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &ModelProto| { &m.domain },
            |m: &mut ModelProto| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version",
            |m: &ModelProto| { &m.model_version },
            |m: &mut ModelProto| { &mut m.model_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "doc_string",
            |m: &ModelProto| { &m.doc_string },
            |m: &mut ModelProto| { &mut m.doc_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GraphProto>(
            "graph",
            |m: &ModelProto| { &m.graph },
            |m: &mut ModelProto| { &mut m.graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metadata_props",
            |m: &ModelProto| { &m.metadata_props },
            |m: &mut ModelProto| { &mut m.metadata_props },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelProto>(
            "ModelProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelProto {
    const NAME: &'static str = "ModelProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ir_version = is.read_int64()?;
                },
                66 => {
                    self.opset_import.push(is.read_message()?);
                },
                18 => {
                    self.producer_name = is.read_string()?;
                },
                26 => {
                    self.producer_version = is.read_string()?;
                },
                34 => {
                    self.domain = is.read_string()?;
                },
                40 => {
                    self.model_version = is.read_int64()?;
                },
                50 => {
                    self.doc_string = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.graph)?;
                },
                114 => {
                    self.metadata_props.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ir_version != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.ir_version);
        }
        for value in &self.opset_import {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.producer_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.producer_name);
        }
        if !self.producer_version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.producer_version);
        }
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.domain);
        }
        if self.model_version != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.model_version);
        }
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.doc_string);
        }
        if let Some(v) = self.graph.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.metadata_props {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ir_version != 0 {
            os.write_int64(1, self.ir_version)?;
        }
        for v in &self.opset_import {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if !self.producer_name.is_empty() {
            os.write_string(2, &self.producer_name)?;
        }
        if !self.producer_version.is_empty() {
            os.write_string(3, &self.producer_version)?;
        }
        if !self.domain.is_empty() {
            os.write_string(4, &self.domain)?;
        }
        if self.model_version != 0 {
            os.write_int64(5, self.model_version)?;
        }
        if !self.doc_string.is_empty() {
            os.write_string(6, &self.doc_string)?;
        }
        if let Some(v) = self.graph.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.metadata_props {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelProto {
        ModelProto::new()
    }

    fn clear(&mut self) {
        self.ir_version = 0;
        self.opset_import.clear();
        self.producer_name.clear();
        self.producer_version.clear();
        self.domain.clear();
        self.model_version = 0;
        self.doc_string.clear();
        self.graph.clear();
        self.metadata_props.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelProto {
        static instance: ModelProto = ModelProto {
            ir_version: 0,
            opset_import: ::std::vec::Vec::new(),
            producer_name: ::std::string::String::new(),
            producer_version: ::std::string::String::new(),
            domain: ::std::string::String::new(),
            model_version: 0,
            doc_string: ::std::string::String::new(),
            graph: ::protobuf::MessageField::none(),
            metadata_props: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:onnx.StringStringEntryProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StringStringEntryProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.StringStringEntryProto.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.StringStringEntryProto.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.StringStringEntryProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringStringEntryProto {
    fn default() -> &'a StringStringEntryProto {
        <StringStringEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl StringStringEntryProto {
    pub fn new() -> StringStringEntryProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &StringStringEntryProto| { &m.key },
            |m: &mut StringStringEntryProto| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &StringStringEntryProto| { &m.value },
            |m: &mut StringStringEntryProto| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringStringEntryProto>(
            "StringStringEntryProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringStringEntryProto {
    const NAME: &'static str = "StringStringEntryProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringStringEntryProto {
        StringStringEntryProto::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringStringEntryProto {
        static instance: StringStringEntryProto = StringStringEntryProto {
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringStringEntryProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringStringEntryProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringStringEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringStringEntryProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:onnx.GraphProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GraphProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.GraphProto.node)
    pub node: ::std::vec::Vec<NodeProto>,
    // @@protoc_insertion_point(field:onnx.GraphProto.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.GraphProto.initializer)
    pub initializer: ::std::vec::Vec<TensorProto>,
    // @@protoc_insertion_point(field:onnx.GraphProto.doc_string)
    pub doc_string: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.GraphProto.input)
    pub input: ::std::vec::Vec<ValueInfoProto>,
    // @@protoc_insertion_point(field:onnx.GraphProto.output)
    pub output: ::std::vec::Vec<ValueInfoProto>,
    // @@protoc_insertion_point(field:onnx.GraphProto.value_info)
    pub value_info: ::std::vec::Vec<ValueInfoProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.GraphProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GraphProto {
    fn default() -> &'a GraphProto {
        <GraphProto as ::protobuf::Message>::default_instance()
    }
}

impl GraphProto {
    pub fn new() -> GraphProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "node",
            |m: &GraphProto| { &m.node },
            |m: &mut GraphProto| { &mut m.node },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &GraphProto| { &m.name },
            |m: &mut GraphProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "initializer",
            |m: &GraphProto| { &m.initializer },
            |m: &mut GraphProto| { &mut m.initializer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "doc_string",
            |m: &GraphProto| { &m.doc_string },
            |m: &mut GraphProto| { &mut m.doc_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input",
            |m: &GraphProto| { &m.input },
            |m: &mut GraphProto| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output",
            |m: &GraphProto| { &m.output },
            |m: &mut GraphProto| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "value_info",
            |m: &GraphProto| { &m.value_info },
            |m: &mut GraphProto| { &mut m.value_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GraphProto>(
            "GraphProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GraphProto {
    const NAME: &'static str = "GraphProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node.push(is.read_message()?);
                },
                18 => {
                    self.name = is.read_string()?;
                },
                42 => {
                    self.initializer.push(is.read_message()?);
                },
                82 => {
                    self.doc_string = is.read_string()?;
                },
                90 => {
                    self.input.push(is.read_message()?);
                },
                98 => {
                    self.output.push(is.read_message()?);
                },
                106 => {
                    self.value_info.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.initializer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.doc_string);
        }
        for value in &self.input {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.output {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.value_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.node {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.initializer {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if !self.doc_string.is_empty() {
            os.write_string(10, &self.doc_string)?;
        }
        for v in &self.input {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.output {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.value_info {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GraphProto {
        GraphProto::new()
    }

    fn clear(&mut self) {
        self.node.clear();
        self.name.clear();
        self.initializer.clear();
        self.doc_string.clear();
        self.input.clear();
        self.output.clear();
        self.value_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GraphProto {
        static instance: GraphProto = GraphProto {
            node: ::std::vec::Vec::new(),
            name: ::std::string::String::new(),
            initializer: ::std::vec::Vec::new(),
            doc_string: ::std::string::String::new(),
            input: ::std::vec::Vec::new(),
            output: ::std::vec::Vec::new(),
            value_info: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GraphProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GraphProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GraphProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:onnx.TensorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TensorProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.TensorProto.dims)
    pub dims: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:onnx.TensorProto.data_type)
    pub data_type: ::protobuf::EnumOrUnknown<tensor_proto::DataType>,
    // @@protoc_insertion_point(field:onnx.TensorProto.segment)
    pub segment: ::protobuf::MessageField<tensor_proto::Segment>,
    // @@protoc_insertion_point(field:onnx.TensorProto.float_data)
    pub float_data: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:onnx.TensorProto.int32_data)
    pub int32_data: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:onnx.TensorProto.string_data)
    pub string_data: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:onnx.TensorProto.int64_data)
    pub int64_data: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:onnx.TensorProto.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.TensorProto.doc_string)
    pub doc_string: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.TensorProto.raw_data)
    pub raw_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:onnx.TensorProto.double_data)
    pub double_data: ::std::vec::Vec<f64>,
    // @@protoc_insertion_point(field:onnx.TensorProto.uint64_data)
    pub uint64_data: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TensorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TensorProto {
    fn default() -> &'a TensorProto {
        <TensorProto as ::protobuf::Message>::default_instance()
    }
}

impl TensorProto {
    pub fn new() -> TensorProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dims",
            |m: &TensorProto| { &m.dims },
            |m: &mut TensorProto| { &mut m.dims },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data_type",
            |m: &TensorProto| { &m.data_type },
            |m: &mut TensorProto| { &mut m.data_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, tensor_proto::Segment>(
            "segment",
            |m: &TensorProto| { &m.segment },
            |m: &mut TensorProto| { &mut m.segment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "float_data",
            |m: &TensorProto| { &m.float_data },
            |m: &mut TensorProto| { &mut m.float_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "int32_data",
            |m: &TensorProto| { &m.int32_data },
            |m: &mut TensorProto| { &mut m.int32_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "string_data",
            |m: &TensorProto| { &m.string_data },
            |m: &mut TensorProto| { &mut m.string_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "int64_data",
            |m: &TensorProto| { &m.int64_data },
            |m: &mut TensorProto| { &mut m.int64_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &TensorProto| { &m.name },
            |m: &mut TensorProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "doc_string",
            |m: &TensorProto| { &m.doc_string },
            |m: &mut TensorProto| { &mut m.doc_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "raw_data",
            |m: &TensorProto| { &m.raw_data },
            |m: &mut TensorProto| { &mut m.raw_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "double_data",
            |m: &TensorProto| { &m.double_data },
            |m: &mut TensorProto| { &mut m.double_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uint64_data",
            |m: &TensorProto| { &m.uint64_data },
            |m: &mut TensorProto| { &mut m.uint64_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TensorProto>(
            "TensorProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TensorProto {
    const NAME: &'static str = "TensorProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int64_into(&mut self.dims)?;
                },
                8 => {
                    self.dims.push(is.read_int64()?);
                },
                16 => {
                    self.data_type = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.segment)?;
                },
                34 => {
                    is.read_repeated_packed_float_into(&mut self.float_data)?;
                },
                37 => {
                    self.float_data.push(is.read_float()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.int32_data)?;
                },
                40 => {
                    self.int32_data.push(is.read_int32()?);
                },
                50 => {
                    self.string_data.push(is.read_bytes()?);
                },
                58 => {
                    is.read_repeated_packed_int64_into(&mut self.int64_data)?;
                },
                56 => {
                    self.int64_data.push(is.read_int64()?);
                },
                66 => {
                    self.name = is.read_string()?;
                },
                98 => {
                    self.doc_string = is.read_string()?;
                },
                74 => {
                    self.raw_data = is.read_bytes()?;
                },
                82 => {
                    is.read_repeated_packed_double_into(&mut self.double_data)?;
                },
                81 => {
                    self.double_data.push(is.read_double()?);
                },
                90 => {
                    is.read_repeated_packed_uint64_into(&mut self.uint64_data)?;
                },
                88 => {
                    self.uint64_data.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dims {
            my_size += ::protobuf::rt::int64_size(1, *value);
        };
        if self.data_type != ::protobuf::EnumOrUnknown::new(tensor_proto::DataType::UNDEFINED) {
            my_size += ::protobuf::rt::int32_size(2, self.data_type.value());
        }
        if let Some(v) = self.segment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_float_size(4, &self.float_data);
        my_size += ::protobuf::rt::vec_packed_int32_size(5, &self.int32_data);
        for value in &self.string_data {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        my_size += ::protobuf::rt::vec_packed_int64_size(7, &self.int64_data);
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.name);
        }
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.doc_string);
        }
        if !self.raw_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.raw_data);
        }
        my_size += ::protobuf::rt::vec_packed_double_size(10, &self.double_data);
        my_size += ::protobuf::rt::vec_packed_uint64_size(11, &self.uint64_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dims {
            os.write_int64(1, *v)?;
        };
        if self.data_type != ::protobuf::EnumOrUnknown::new(tensor_proto::DataType::UNDEFINED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.data_type))?;
        }
        if let Some(v) = self.segment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_repeated_packed_float(4, &self.float_data)?;
        os.write_repeated_packed_int32(5, &self.int32_data)?;
        for v in &self.string_data {
            os.write_bytes(6, &v)?;
        };
        os.write_repeated_packed_int64(7, &self.int64_data)?;
        if !self.name.is_empty() {
            os.write_string(8, &self.name)?;
        }
        if !self.doc_string.is_empty() {
            os.write_string(12, &self.doc_string)?;
        }
        if !self.raw_data.is_empty() {
            os.write_bytes(9, &self.raw_data)?;
        }
        os.write_repeated_packed_double(10, &self.double_data)?;
        os.write_repeated_packed_uint64(11, &self.uint64_data)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TensorProto {
        TensorProto::new()
    }

    fn clear(&mut self) {
        self.dims.clear();
        self.data_type = ::protobuf::EnumOrUnknown::new(tensor_proto::DataType::UNDEFINED);
        self.segment.clear();
        self.float_data.clear();
        self.int32_data.clear();
        self.string_data.clear();
        self.int64_data.clear();
        self.name.clear();
        self.doc_string.clear();
        self.raw_data.clear();
        self.double_data.clear();
        self.uint64_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TensorProto {
        static instance: TensorProto = TensorProto {
            dims: ::std::vec::Vec::new(),
            data_type: ::protobuf::EnumOrUnknown::from_i32(0),
            segment: ::protobuf::MessageField::none(),
            float_data: ::std::vec::Vec::new(),
            int32_data: ::std::vec::Vec::new(),
            string_data: ::std::vec::Vec::new(),
            int64_data: ::std::vec::Vec::new(),
            name: ::std::string::String::new(),
            doc_string: ::std::string::String::new(),
            raw_data: ::std::vec::Vec::new(),
            double_data: ::std::vec::Vec::new(),
            uint64_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TensorProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TensorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TensorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TensorProto`
pub mod tensor_proto {
    // @@protoc_insertion_point(message:onnx.TensorProto.Segment)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Segment {
        // message fields
        // @@protoc_insertion_point(field:onnx.TensorProto.Segment.begin)
        pub begin: i64,
        // @@protoc_insertion_point(field:onnx.TensorProto.Segment.end)
        pub end: i64,
        // special fields
        // @@protoc_insertion_point(special_field:onnx.TensorProto.Segment.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Segment {
        fn default() -> &'a Segment {
            <Segment as ::protobuf::Message>::default_instance()
        }
    }

    impl Segment {
        pub fn new() -> Segment {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "begin",
                |m: &Segment| { &m.begin },
                |m: &mut Segment| { &mut m.begin },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "end",
                |m: &Segment| { &m.end },
                |m: &mut Segment| { &mut m.end },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Segment>(
                "TensorProto.Segment",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Segment {
        const NAME: &'static str = "Segment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.begin = is.read_int64()?;
                    },
                    16 => {
                        self.end = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.begin != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.begin);
            }
            if self.end != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.end);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.begin != 0 {
                os.write_int64(1, self.begin)?;
            }
            if self.end != 0 {
                os.write_int64(2, self.end)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Segment {
            Segment::new()
        }

        fn clear(&mut self) {
            self.begin = 0;
            self.end = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Segment {
            static instance: Segment = Segment {
                begin: 0,
                end: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Segment {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TensorProto.Segment").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Segment {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Segment {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:onnx.TensorProto.DataType)
    pub enum DataType {
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UNDEFINED)
        UNDEFINED = 0,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.FLOAT)
        FLOAT = 1,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT8)
        UINT8 = 2,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT8)
        INT8 = 3,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT16)
        UINT16 = 4,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT16)
        INT16 = 5,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT32)
        INT32 = 6,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT64)
        INT64 = 7,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.STRING)
        STRING = 8,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.BOOL)
        BOOL = 9,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.FLOAT16)
        FLOAT16 = 10,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.DOUBLE)
        DOUBLE = 11,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT32)
        UINT32 = 12,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT64)
        UINT64 = 13,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.COMPLEX64)
        COMPLEX64 = 14,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.COMPLEX128)
        COMPLEX128 = 15,
    }

    impl ::protobuf::Enum for DataType {
        const NAME: &'static str = "DataType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DataType> {
            match value {
                0 => ::std::option::Option::Some(DataType::UNDEFINED),
                1 => ::std::option::Option::Some(DataType::FLOAT),
                2 => ::std::option::Option::Some(DataType::UINT8),
                3 => ::std::option::Option::Some(DataType::INT8),
                4 => ::std::option::Option::Some(DataType::UINT16),
                5 => ::std::option::Option::Some(DataType::INT16),
                6 => ::std::option::Option::Some(DataType::INT32),
                7 => ::std::option::Option::Some(DataType::INT64),
                8 => ::std::option::Option::Some(DataType::STRING),
                9 => ::std::option::Option::Some(DataType::BOOL),
                10 => ::std::option::Option::Some(DataType::FLOAT16),
                11 => ::std::option::Option::Some(DataType::DOUBLE),
                12 => ::std::option::Option::Some(DataType::UINT32),
                13 => ::std::option::Option::Some(DataType::UINT64),
                14 => ::std::option::Option::Some(DataType::COMPLEX64),
                15 => ::std::option::Option::Some(DataType::COMPLEX128),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<DataType> {
            match str {
                "UNDEFINED" => ::std::option::Option::Some(DataType::UNDEFINED),
                "FLOAT" => ::std::option::Option::Some(DataType::FLOAT),
                "UINT8" => ::std::option::Option::Some(DataType::UINT8),
                "INT8" => ::std::option::Option::Some(DataType::INT8),
                "UINT16" => ::std::option::Option::Some(DataType::UINT16),
                "INT16" => ::std::option::Option::Some(DataType::INT16),
                "INT32" => ::std::option::Option::Some(DataType::INT32),
                "INT64" => ::std::option::Option::Some(DataType::INT64),
                "STRING" => ::std::option::Option::Some(DataType::STRING),
                "BOOL" => ::std::option::Option::Some(DataType::BOOL),
                "FLOAT16" => ::std::option::Option::Some(DataType::FLOAT16),
                "DOUBLE" => ::std::option::Option::Some(DataType::DOUBLE),
                "UINT32" => ::std::option::Option::Some(DataType::UINT32),
                "UINT64" => ::std::option::Option::Some(DataType::UINT64),
                "COMPLEX64" => ::std::option::Option::Some(DataType::COMPLEX64),
                "COMPLEX128" => ::std::option::Option::Some(DataType::COMPLEX128),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DataType] = &[
            DataType::UNDEFINED,
            DataType::FLOAT,
            DataType::UINT8,
            DataType::INT8,
            DataType::UINT16,
            DataType::INT16,
            DataType::INT32,
            DataType::INT64,
            DataType::STRING,
            DataType::BOOL,
            DataType::FLOAT16,
            DataType::DOUBLE,
            DataType::UINT32,
            DataType::UINT64,
            DataType::COMPLEX64,
            DataType::COMPLEX128,
        ];
    }

    impl ::protobuf::EnumFull for DataType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TensorProto.DataType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DataType {
        fn default() -> Self {
            DataType::UNDEFINED
        }
    }

    impl DataType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DataType>("TensorProto.DataType")
        }
    }
}

// @@protoc_insertion_point(message:onnx.TensorShapeProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TensorShapeProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.TensorShapeProto.dim)
    pub dim: ::std::vec::Vec<tensor_shape_proto::Dimension>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TensorShapeProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TensorShapeProto {
    fn default() -> &'a TensorShapeProto {
        <TensorShapeProto as ::protobuf::Message>::default_instance()
    }
}

impl TensorShapeProto {
    pub fn new() -> TensorShapeProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dim",
            |m: &TensorShapeProto| { &m.dim },
            |m: &mut TensorShapeProto| { &mut m.dim },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TensorShapeProto>(
            "TensorShapeProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TensorShapeProto {
    const NAME: &'static str = "TensorShapeProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dim.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dim {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dim {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TensorShapeProto {
        TensorShapeProto::new()
    }

    fn clear(&mut self) {
        self.dim.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TensorShapeProto {
        static instance: TensorShapeProto = TensorShapeProto {
            dim: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TensorShapeProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TensorShapeProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TensorShapeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorShapeProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TensorShapeProto`
pub mod tensor_shape_proto {
    // @@protoc_insertion_point(message:onnx.TensorShapeProto.Dimension)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Dimension {
        // message oneof groups
        pub value: ::std::option::Option<dimension::Value>,
        // special fields
        // @@protoc_insertion_point(special_field:onnx.TensorShapeProto.Dimension.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Dimension {
        fn default() -> &'a Dimension {
            <Dimension as ::protobuf::Message>::default_instance()
        }
    }

    impl Dimension {
        pub fn new() -> Dimension {
            ::std::default::Default::default()
        }

        // int64 dim_value = 1;

        pub fn dim_value(&self) -> i64 {
            match self.value {
                ::std::option::Option::Some(dimension::Value::DimValue(v)) => v,
                _ => 0,
            }
        }

        pub fn clear_dim_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_dim_value(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(dimension::Value::DimValue(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_dim_value(&mut self, v: i64) {
            self.value = ::std::option::Option::Some(dimension::Value::DimValue(v))
        }

        // string dim_param = 2;

        pub fn dim_param(&self) -> &str {
            match self.value {
                ::std::option::Option::Some(dimension::Value::DimParam(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_dim_param(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_dim_param(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(dimension::Value::DimParam(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_dim_param(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(dimension::Value::DimParam(v))
        }

        // Mutable pointer to the field.
        pub fn mut_dim_param(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(dimension::Value::DimParam(_)) = self.value {
            } else {
                self.value = ::std::option::Option::Some(dimension::Value::DimParam(::std::string::String::new()));
            }
            match self.value {
                ::std::option::Option::Some(dimension::Value::DimParam(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_dim_param(&mut self) -> ::std::string::String {
            if self.has_dim_param() {
                match self.value.take() {
                    ::std::option::Option::Some(dimension::Value::DimParam(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "dim_value",
                Dimension::has_dim_value,
                Dimension::dim_value,
                Dimension::set_dim_value,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                "dim_param",
                Dimension::has_dim_param,
                Dimension::dim_param,
                Dimension::set_dim_param,
            ));
            oneofs.push(dimension::Value::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Dimension>(
                "TensorShapeProto.Dimension",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Dimension {
        const NAME: &'static str = "Dimension";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.value = ::std::option::Option::Some(dimension::Value::DimValue(is.read_int64()?));
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(dimension::Value::DimParam(is.read_string()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.value {
                match v {
                    &dimension::Value::DimValue(v) => {
                        my_size += ::protobuf::rt::int64_size(1, v);
                    },
                    &dimension::Value::DimParam(ref v) => {
                        my_size += ::protobuf::rt::string_size(2, &v);
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.value {
                match v {
                    &dimension::Value::DimValue(v) => {
                        os.write_int64(1, v)?;
                    },
                    &dimension::Value::DimParam(ref v) => {
                        os.write_string(2, v)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Dimension {
            Dimension::new()
        }

        fn clear(&mut self) {
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Dimension {
            static instance: Dimension = Dimension {
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Dimension {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TensorShapeProto.Dimension").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Dimension {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Dimension {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Dimension`
    pub mod dimension {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:onnx.TensorShapeProto.Dimension.value)
        pub enum Value {
            // @@protoc_insertion_point(oneof_field:onnx.TensorShapeProto.Dimension.dim_value)
            DimValue(i64),
            // @@protoc_insertion_point(oneof_field:onnx.TensorShapeProto.Dimension.dim_param)
            DimParam(::std::string::String),
        }

        impl ::protobuf::Oneof for Value {
        }

        impl ::protobuf::OneofFull for Value {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Dimension as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
            }
        }

        impl Value {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
            }
        }
    }
}

// @@protoc_insertion_point(message:onnx.TypeProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeProto {
    // message oneof groups
    pub value: ::std::option::Option<type_proto::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TypeProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TypeProto {
    fn default() -> &'a TypeProto {
        <TypeProto as ::protobuf::Message>::default_instance()
    }
}

impl TypeProto {
    pub fn new() -> TypeProto {
        ::std::default::Default::default()
    }

    // .onnx.TypeProto.Tensor tensor_type = 1;

    pub fn tensor_type(&self) -> &type_proto::Tensor {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::TensorType(ref v)) => v,
            _ => <type_proto::Tensor as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tensor_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_tensor_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::TensorType(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tensor_type(&mut self, v: type_proto::Tensor) {
        self.value = ::std::option::Option::Some(type_proto::Value::TensorType(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tensor_type(&mut self) -> &mut type_proto::Tensor {
        if let ::std::option::Option::Some(type_proto::Value::TensorType(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(type_proto::Value::TensorType(type_proto::Tensor::new()));
        }
        match self.value {
            ::std::option::Option::Some(type_proto::Value::TensorType(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tensor_type(&mut self) -> type_proto::Tensor {
        if self.has_tensor_type() {
            match self.value.take() {
                ::std::option::Option::Some(type_proto::Value::TensorType(v)) => v,
                _ => panic!(),
            }
        } else {
            type_proto::Tensor::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_proto::Tensor>(
            "tensor_type",
            TypeProto::has_tensor_type,
            TypeProto::tensor_type,
            TypeProto::mut_tensor_type,
            TypeProto::set_tensor_type,
        ));
        oneofs.push(type_proto::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeProto>(
            "TypeProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TypeProto {
    const NAME: &'static str = "TypeProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(type_proto::Value::TensorType(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &type_proto::Value::TensorType(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &type_proto::Value::TensorType(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TypeProto {
        TypeProto::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TypeProto {
        static instance: TypeProto = TypeProto {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TypeProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TypeProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TypeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TypeProto`
pub mod type_proto {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:onnx.TypeProto.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:onnx.TypeProto.tensor_type)
        TensorType(Tensor),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TypeProto as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
    // @@protoc_insertion_point(message:onnx.TypeProto.Tensor)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tensor {
        // message fields
        // @@protoc_insertion_point(field:onnx.TypeProto.Tensor.elem_type)
        pub elem_type: ::protobuf::EnumOrUnknown<super::tensor_proto::DataType>,
        // @@protoc_insertion_point(field:onnx.TypeProto.Tensor.shape)
        pub shape: ::protobuf::MessageField<super::TensorShapeProto>,
        // special fields
        // @@protoc_insertion_point(special_field:onnx.TypeProto.Tensor.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tensor {
        fn default() -> &'a Tensor {
            <Tensor as ::protobuf::Message>::default_instance()
        }
    }

    impl Tensor {
        pub fn new() -> Tensor {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "elem_type",
                |m: &Tensor| { &m.elem_type },
                |m: &mut Tensor| { &mut m.elem_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::TensorShapeProto>(
                "shape",
                |m: &Tensor| { &m.shape },
                |m: &mut Tensor| { &mut m.shape },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tensor>(
                "TypeProto.Tensor",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Tensor {
        const NAME: &'static str = "Tensor";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.elem_type = is.read_enum_or_unknown()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.shape)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.elem_type != ::protobuf::EnumOrUnknown::new(super::tensor_proto::DataType::UNDEFINED) {
                my_size += ::protobuf::rt::int32_size(1, self.elem_type.value());
            }
            if let Some(v) = self.shape.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.elem_type != ::protobuf::EnumOrUnknown::new(super::tensor_proto::DataType::UNDEFINED) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.elem_type))?;
            }
            if let Some(v) = self.shape.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tensor {
            Tensor::new()
        }

        fn clear(&mut self) {
            self.elem_type = ::protobuf::EnumOrUnknown::new(super::tensor_proto::DataType::UNDEFINED);
            self.shape.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tensor {
            static instance: Tensor = Tensor {
                elem_type: ::protobuf::EnumOrUnknown::from_i32(0),
                shape: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Tensor {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TypeProto.Tensor").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tensor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Tensor {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:onnx.OperatorSetIdProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OperatorSetIdProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.OperatorSetIdProto.domain)
    pub domain: ::std::string::String,
    // @@protoc_insertion_point(field:onnx.OperatorSetIdProto.version)
    pub version: i64,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.OperatorSetIdProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperatorSetIdProto {
    fn default() -> &'a OperatorSetIdProto {
        <OperatorSetIdProto as ::protobuf::Message>::default_instance()
    }
}

impl OperatorSetIdProto {
    pub fn new() -> OperatorSetIdProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &OperatorSetIdProto| { &m.domain },
            |m: &mut OperatorSetIdProto| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &OperatorSetIdProto| { &m.version },
            |m: &mut OperatorSetIdProto| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OperatorSetIdProto>(
            "OperatorSetIdProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OperatorSetIdProto {
    const NAME: &'static str = "OperatorSetIdProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domain = is.read_string()?;
                },
                16 => {
                    self.version = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        if self.version != 0 {
            os.write_int64(2, self.version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperatorSetIdProto {
        OperatorSetIdProto::new()
    }

    fn clear(&mut self) {
        self.domain.clear();
        self.version = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperatorSetIdProto {
        static instance: OperatorSetIdProto = OperatorSetIdProto {
            domain: ::std::string::String::new(),
            version: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OperatorSetIdProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OperatorSetIdProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OperatorSetIdProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorSetIdProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:onnx.Version)
pub enum Version {
    // @@protoc_insertion_point(enum_value:onnx.Version._START_VERSION)
    _START_VERSION = 0,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2017_10_10)
    IR_VERSION_2017_10_10 = 1,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2017_10_30)
    IR_VERSION_2017_10_30 = 2,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION)
    IR_VERSION = 3,
}

impl ::protobuf::Enum for Version {
    const NAME: &'static str = "Version";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Version> {
        match value {
            0 => ::std::option::Option::Some(Version::_START_VERSION),
            1 => ::std::option::Option::Some(Version::IR_VERSION_2017_10_10),
            2 => ::std::option::Option::Some(Version::IR_VERSION_2017_10_30),
            3 => ::std::option::Option::Some(Version::IR_VERSION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Version> {
        match str {
            "_START_VERSION" => ::std::option::Option::Some(Version::_START_VERSION),
            "IR_VERSION_2017_10_10" => ::std::option::Option::Some(Version::IR_VERSION_2017_10_10),
            "IR_VERSION_2017_10_30" => ::std::option::Option::Some(Version::IR_VERSION_2017_10_30),
            "IR_VERSION" => ::std::option::Option::Some(Version::IR_VERSION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Version] = &[
        Version::_START_VERSION,
        Version::IR_VERSION_2017_10_10,
        Version::IR_VERSION_2017_10_30,
        Version::IR_VERSION,
    ];
}

impl ::protobuf::EnumFull for Version {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Version").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Version {
    fn default() -> Self {
        Version::_START_VERSION
    }
}

impl Version {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Version>("Version")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dparser/onnx_model/onnx.proto3\x12\x04onnx\"\x97\x04\n\x0eAttribute\
    Proto\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1d\n\ndoc_strin\
    g\x18\r\x20\x01(\tR\tdocString\x126\n\x04type\x18\x14\x20\x01(\x0e2\".on\
    nx.AttributeProto.AttributeTypeR\x04type\x12\x0c\n\x01f\x18\x02\x20\x01(\
    \x02R\x01f\x12\x0c\n\x01i\x18\x03\x20\x01(\x03R\x01i\x12\x0c\n\x01s\x18\
    \x04\x20\x01(\x0cR\x01s\x12\x1f\n\x01t\x18\x05\x20\x01(\x0b2\x11.onnx.Te\
    nsorProtoR\x01t\x12\x1e\n\x01g\x18\x06\x20\x01(\x0b2\x10.onnx.GraphProto\
    R\x01g\x12\x16\n\x06floats\x18\x07\x20\x03(\x02R\x06floats\x12\x12\n\x04\
    ints\x18\x08\x20\x03(\x03R\x04ints\x12\x18\n\x07strings\x18\t\x20\x03(\
    \x0cR\x07strings\x12+\n\x07tensors\x18\n\x20\x03(\x0b2\x11.onnx.TensorPr\
    otoR\x07tensors\x12(\n\x06graphs\x18\x0b\x20\x03(\x0b2\x10.onnx.GraphPro\
    toR\x06graphs\"\x91\x01\n\rAttributeType\x12\r\n\tUNDEFINED\x10\0\x12\t\
    \n\x05FLOAT\x10\x01\x12\x07\n\x03INT\x10\x02\x12\n\n\x06STRING\x10\x03\
    \x12\n\n\x06TENSOR\x10\x04\x12\t\n\x05GRAPH\x10\x05\x12\n\n\x06FLOATS\
    \x10\x06\x12\x08\n\x04INTS\x10\x07\x12\x0b\n\x07STRINGS\x10\x08\x12\x0b\
    \n\x07TENSORS\x10\t\x12\n\n\x06GRAPHS\x10\n\"h\n\x0eValueInfoProto\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12#\n\x04type\x18\x02\x20\
    \x01(\x0b2\x0f.onnx.TypeProtoR\x04type\x12\x1d\n\ndoc_string\x18\x03\x20\
    \x01(\tR\tdocString\"\xd1\x01\n\tNodeProto\x12\x14\n\x05input\x18\x01\
    \x20\x03(\tR\x05input\x12\x16\n\x06output\x18\x02\x20\x03(\tR\x06output\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x17\n\x07op_type\x18\
    \x04\x20\x01(\tR\x06opType\x12\x16\n\x06domain\x18\x07\x20\x01(\tR\x06do\
    main\x122\n\tattribute\x18\x05\x20\x03(\x0b2\x14.onnx.AttributeProtoR\ta\
    ttribute\x12\x1d\n\ndoc_string\x18\x06\x20\x01(\tR\tdocString\"\x81\x03\
    \n\nModelProto\x12\x1d\n\nir_version\x18\x01\x20\x01(\x03R\tirVersion\
    \x12;\n\x0copset_import\x18\x08\x20\x03(\x0b2\x18.onnx.OperatorSetIdProt\
    oR\x0bopsetImport\x12#\n\rproducer_name\x18\x02\x20\x01(\tR\x0cproducerN\
    ame\x12)\n\x10producer_version\x18\x03\x20\x01(\tR\x0fproducerVersion\
    \x12\x16\n\x06domain\x18\x04\x20\x01(\tR\x06domain\x12#\n\rmodel_version\
    \x18\x05\x20\x01(\x03R\x0cmodelVersion\x12\x1d\n\ndoc_string\x18\x06\x20\
    \x01(\tR\tdocString\x12&\n\x05graph\x18\x07\x20\x01(\x0b2\x10.onnx.Graph\
    ProtoR\x05graph\x12C\n\x0emetadata_props\x18\x0e\x20\x03(\x0b2\x1c.onnx.\
    StringStringEntryProtoR\rmetadataProps\"@\n\x16StringStringEntryProto\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value\"\xa8\x02\n\nGraphProto\x12#\n\x04node\x18\x01\x20\
    \x03(\x0b2\x0f.onnx.NodeProtoR\x04node\x12\x12\n\x04name\x18\x02\x20\x01\
    (\tR\x04name\x123\n\x0binitializer\x18\x05\x20\x03(\x0b2\x11.onnx.Tensor\
    ProtoR\x0binitializer\x12\x1d\n\ndoc_string\x18\n\x20\x01(\tR\tdocString\
    \x12*\n\x05input\x18\x0b\x20\x03(\x0b2\x14.onnx.ValueInfoProtoR\x05input\
    \x12,\n\x06output\x18\x0c\x20\x03(\x0b2\x14.onnx.ValueInfoProtoR\x06outp\
    ut\x123\n\nvalue_info\x18\r\x20\x03(\x0b2\x14.onnx.ValueInfoProtoR\tvalu\
    eInfo\"\xb3\x05\n\x0bTensorProto\x12\x12\n\x04dims\x18\x01\x20\x03(\x03R\
    \x04dims\x127\n\tdata_type\x18\x02\x20\x01(\x0e2\x1a.onnx.TensorProto.Da\
    taTypeR\x08dataType\x123\n\x07segment\x18\x03\x20\x01(\x0b2\x19.onnx.Ten\
    sorProto.SegmentR\x07segment\x12!\n\nfloat_data\x18\x04\x20\x03(\x02R\tf\
    loatDataB\x02\x10\x01\x12!\n\nint32_data\x18\x05\x20\x03(\x05R\tint32Dat\
    aB\x02\x10\x01\x12\x1f\n\x0bstring_data\x18\x06\x20\x03(\x0cR\nstringDat\
    a\x12!\n\nint64_data\x18\x07\x20\x03(\x03R\tint64DataB\x02\x10\x01\x12\
    \x12\n\x04name\x18\x08\x20\x01(\tR\x04name\x12\x1d\n\ndoc_string\x18\x0c\
    \x20\x01(\tR\tdocString\x12\x19\n\x08raw_data\x18\t\x20\x01(\x0cR\x07raw\
    Data\x12#\n\x0bdouble_data\x18\n\x20\x03(\x01R\ndoubleDataB\x02\x10\x01\
    \x12#\n\x0buint64_data\x18\x0b\x20\x03(\x04R\nuint64DataB\x02\x10\x01\
    \x1a1\n\x07Segment\x12\x14\n\x05begin\x18\x01\x20\x01(\x03R\x05begin\x12\
    \x10\n\x03end\x18\x02\x20\x01(\x03R\x03end\"\xcc\x01\n\x08DataType\x12\r\
    \n\tUNDEFINED\x10\0\x12\t\n\x05FLOAT\x10\x01\x12\t\n\x05UINT8\x10\x02\
    \x12\x08\n\x04INT8\x10\x03\x12\n\n\x06UINT16\x10\x04\x12\t\n\x05INT16\
    \x10\x05\x12\t\n\x05INT32\x10\x06\x12\t\n\x05INT64\x10\x07\x12\n\n\x06ST\
    RING\x10\x08\x12\x08\n\x04BOOL\x10\t\x12\x0b\n\x07FLOAT16\x10\n\x12\n\n\
    \x06DOUBLE\x10\x0b\x12\n\n\x06UINT32\x10\x0c\x12\n\n\x06UINT64\x10\r\x12\
    \r\n\tCOMPLEX64\x10\x0e\x12\x0e\n\nCOMPLEX128\x10\x0f\"\x9a\x01\n\x10Ten\
    sorShapeProto\x122\n\x03dim\x18\x01\x20\x03(\x0b2\x20.onnx.TensorShapePr\
    oto.DimensionR\x03dim\x1aR\n\tDimension\x12\x1d\n\tdim_value\x18\x01\x20\
    \x01(\x03H\0R\x08dimValue\x12\x1d\n\tdim_param\x18\x02\x20\x01(\tH\0R\
    \x08dimParamB\x07\n\x05value\"\xc0\x01\n\tTypeProto\x129\n\x0btensor_typ\
    e\x18\x01\x20\x01(\x0b2\x16.onnx.TypeProto.TensorH\0R\ntensorType\x1ao\n\
    \x06Tensor\x127\n\telem_type\x18\x01\x20\x01(\x0e2\x1a.onnx.TensorProto.\
    DataTypeR\x08elemType\x12,\n\x05shape\x18\x02\x20\x01(\x0b2\x16.onnx.Ten\
    sorShapeProtoR\x05shapeB\x07\n\x05value\"F\n\x12OperatorSetIdProto\x12\
    \x16\n\x06domain\x18\x01\x20\x01(\tR\x06domain\x12\x18\n\x07version\x18\
    \x02\x20\x01(\x03R\x07version*c\n\x07Version\x12\x12\n\x0e_START_VERSION\
    \x10\0\x12\x19\n\x15IR_VERSION_2017_10_10\x10\x01\x12\x19\n\x15IR_VERSIO\
    N_2017_10_30\x10\x02\x12\x0e\n\nIR_VERSION\x10\x03b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(13);
            messages.push(AttributeProto::generated_message_descriptor_data());
            messages.push(ValueInfoProto::generated_message_descriptor_data());
            messages.push(NodeProto::generated_message_descriptor_data());
            messages.push(ModelProto::generated_message_descriptor_data());
            messages.push(StringStringEntryProto::generated_message_descriptor_data());
            messages.push(GraphProto::generated_message_descriptor_data());
            messages.push(TensorProto::generated_message_descriptor_data());
            messages.push(TensorShapeProto::generated_message_descriptor_data());
            messages.push(TypeProto::generated_message_descriptor_data());
            messages.push(OperatorSetIdProto::generated_message_descriptor_data());
            messages.push(tensor_proto::Segment::generated_message_descriptor_data());
            messages.push(tensor_shape_proto::Dimension::generated_message_descriptor_data());
            messages.push(type_proto::Tensor::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(Version::generated_enum_descriptor_data());
            enums.push(attribute_proto::AttributeType::generated_enum_descriptor_data());
            enums.push(tensor_proto::DataType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
